\documentclass[a4paper]{report}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}
\usepackage{mathbbol}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{lipsum}
\usepackage{fancyvrb}
\usepackage{natbib}


\title{Adaptive Bitrate Streaming: a buffer-based approach } 

\author{Piergiorgio Ladisa
\\
Nicola Sebastianelli}
\date{22/11/2018}


\makeindex

\begin{document}
\maketitle
\tableofcontents
\listoffigures
\newpage

\part*{Buffer-based ABR Algorithm}
These days we are witnessing to the continuous growing demand of streamed content in network: anyone asks anywhere and in any-moment for contents to servers from their mobile devices. Hence, since the percentage of contents in the network is becoming everyday bigger, CDNs and ISPs are called to respond to this demand.
The paradigm of the multimedia systems and for CDN is mainly the so-called Quality of Experience (QoE). This is very different from the paradigm on which Internet was designed, i.e. Quality of Service (QoS) and Best Effort, in fact the quality of experience is really subjective and very difficult to measure. Nevertheless, different protocols and strategies have been proposed in order to met the demand of users of streaming of contents. 
Firstly, different strategies of streaming exists:
\begin{itemize}
\item all-in-once, i.e. the content is entirely sent to the user. This approach is enforced by the server and the encoding rate is unintentional, since the client's buffer is filled up, in the same way in which the TCP buffer is filled up; since TCP performs the flow control, the client with this approach read at the encoding rate;
\item throttling, i.e. the rate is adapted to the user with two possible approach:
\begin{itemize}
\item on-off-S, in which the connection is maintained persistently;
\item on-off-M, in which the connection is not maintained persistently
\end{itemize}
These two approaches are caused by the client application, that periodically stops reading from the TCP socket. In a general case of  pseudo-streaming, the video is buffered until the buffer is enough full and, once reached the steady state, the controller starts doing an on-off step, downloading the block size of the video.
\end{itemize}
In this context, the mainly adopted protocol is HTTP Adaptive Streaming protocol (HAS). Here the idea is to make the requested bitrate of the video fit with the varying network resources, ensuring the best possible quality of experience for the user, based on the current situation of the network.
This adaptation is usually done on client-side. Here the content is divided in chunks and available in different qualities. So HAS allows to encode each segment in different quality referring to the current bandwidth and so the stream is splitted into a sequence of segments, instead of downloading one entire large file (as in the all-in-once approach). The policies of HAS are:
\begin{itemize}
\item Rate-based, that select the highest possible video representation referring to the measured speed from the previous received chunk;
\item Buffer-based, that uses different thresholds for the buffer in a way in which the more the buffer is filled, the more quality of the video is. Thus, with this approach, the quality can switch step-by-steo at each new request of a video segment: it is impossible to jump from the lowest to the highest quality just in one step;
\item Buffer and Rate based. This is an hybrid approach, i.e. is based on the rate-based approach basically, but the previous chunk download speed is weighted using a factor that depends on the amount of the saturation of the buffer: if the buffer is depleting the previous chunk, the download speed will be considered to be less than the measured one and hence a lower quality is selected. 
\end{itemize}

\chapter{A buffer-based approach to rate adaptation}
When the client want to access to a video-content for streaming, it chooses which the video rate to stream by monitoring network conditions and estimating the available network capacity. This process is referred to as \textit{adaptive bit rate selection} or \textit{ABR}.
ABR algorithms try to balance two opposite goals. The first goal is  to maximize the video quality choosing as video rate the highest supportable by the network. The second goal is to minimize re-buffering events, which cause the video to halt if the client?s playback buffer goes empty. Data is requested in chunks and the buffer drains at 1 unit/second. So if the video-rate $R(t)$ is greater than the system capacity $C(t)$, new data is added at $C(T)/R(T)<1$, depleting the buffer.
\begin{figure}[H]
  \begin{center}
    \includegraphics[width=0.5\textwidth]{buffer}
  \end{center}
  \caption{Relationship between system capacity and video rate in video playback buffer ~\citep{Huang:2014:BAR:2740070.2626296} }\label{buffer}
\end{figure}

In order to maximize video quality, a service could just stream at the maximum video rate $R_{max}$ all the time, but this would risk extensive re-buffering. On the other hand, to minimize rebuffering, the service could just stream at the minimum video rate $Rmin$ all the time but this extreme would lead to low video quality. Hence, the design goal of an ABR algorithm is to simultaneously obtain high performance on both metrics in order to give users a good quality of experience.
Firstly, the client measures how fast chunks arrive to estimate capacity, let us say $C\textit{(}t\textit{)}$. The estimate enriched with knowledge of the buffer occupancy, which is represented with an  adjustment factor  $F\textit{(}B\textit{(}t\textit{)}\textit{)}$, i.e. a function of the playback buffer occupancy. So, the selected video rate is $R\textit{(}t\textit{)} = F(B\textit{(}t\textit{)})C\textit{(}t\textit{)}$; different designs use different adjustment functions $F\textit{(}.\textit{)}$.
When the buffer contains many chunks, $R(t)$ can safely deviate from $C(t)$ without triggering a rebuffer. The client can aggressively try to maximize the video quality by picking $R(t) = C(t)$. But when the buffer is low, the client should be more conservative.

We say that an ABR algorithm is \textit{buffer-based} if it picks the video rate as a function of the current buffer occupancy $B(t)$.
The region between:
\begin{itemize}
\item $[0, B_{max}]$ on the buffer-axis;
\item $[R_{min}, R_{max}]$ on the rate-axis;
\end{itemize}
defines the feasible region. So, any curve $f(B)$ on the plane within the feasible region defines a \textit{rate map}, i.e. a function that produces a video rate between $R_{min}$ and $R_{max}$ given the current buffer occupancy.
Let us assume that:
\begin{itemize}
\item the chunk-size is infinitesimal;
\item video rates within $[R_{min}, R_{max}]$ are continuous;
\item videos are encoded at a constant bitrate;
\item videos are infinitely long;
\end{itemize}
Thus, as long as $C(t) \geq R_{min}$ and $f(B)$ tends to $R_{min}$ when $B$ tends to $0$, there will not be unnecessary rebuffering events. So, as long as $f(B)$ increases to $R_{max}$, the average video rate will match the average capacity when it is true that $R_{min}<C(t)<R_{max}$.

\section{BBA0-Algorithm}
The rate map implemented by the BBA0 algorithm is the following:

\begin{figure}[H]
  \begin{center}
    \includegraphics[width=0.7\textwidth]{ratemapBBA0}
  \end{center}
  \caption{Rate map of the BBA0 algorithm ~\citep{Huang:2014:BAR:2740070.2626296} }\label{ratemapBBA0}
\end{figure}

This algorithm add reservoir $r$ to pad for finite chunk sizes and some $C(t)$ variation. So, while filling reservoir, it request $R_{min}$ and must have $r$ greater or equal to the minimum chunk size. In addition, an upper reservoir is added to reach $R_{max}$ before the buffer B is full and above the "safe area" is where the buffer will not deplete into $r$ if $C(t)$ suddenly drops, but does not reach values lower than $R_{min}$.

\subsection{BBA0 Algorithm}
The algorithm presented in ~\citep{Huang:2014:BAR:2740070.2626296}, in pseudo-code, is the following:

\textbf{Input}: 
\begin{itemize}
\item Rate$_{prev}$: previously used video rate;

\item Buf$_{now}$: current buffer occupancy;

\item r: size of reservoir;

\item cu: size of cushion.

\end{itemize}

\textbf{Output}: Rate$_{next}$: next video rate.

\begin{Verbatim}
if Rate_prev = R_max then
	Rate+ = R_max
else
	Rate+ = min{Ri : Ri > Rate_prev}

if Rate_prev = R_min then
	Rate- = R_min
else
	Rate- = max{Ri : Ri < Rate_prev}

if Buf_now <= r then
	Rate_next = R_min

else if Buf_now >= (r + cu) then
	Rate_next = R_max

else if f(Buf_now) >= Rate+ then
	Rate_next = max{Ri : Ri < f(Buf_now)};

else if f(Buf_now) <= Rate- then
	Rate_next = min{Ri : Ri > f(Buf_now)};

else
	Rate_next = Rate_prev;

return Rate_next;
	
	
\end{Verbatim}

This constitute a buffer-based algorithm to the rate adaptation in playing contents from the client.

\subsection{Implementation of BBA0 Algorithm}
The implementation that we have done of the BBA0 algorithm is written in Python and is presented below.

Since the BBA0 Algorithm regards the algorithm for the controller in the player, what we have implemented is a controller used by the player defined in the script \textit{play.py}.

Firstly, we have defined the class BBA0Controller, in order to be imported by the player and executed through the specification of the use of this controller. So the definition of the class is the following:
\begin{Verbatim}

class BBA0Controller(BaseController):

    def __init__(self):
        super(BBA0Controller, self).__init__()

    def __repr__(self):
        return '<BBA0Controller-%d>' % id(self)
\end{Verbatim}


The code below specifies the rate-map function $f(B)$, that is the line passing from the points $(reservoir, R_{min})$ and $(reservoir+cushion, R_{max})$. Hence the equation for the line is the following:

\[
f(B) = B *(\frac{(R_{max} - R_{min})}{cushion} + (R_{min} - \frac{reservoir}{cushion}) * (R_{max} - R_{min})
\]

so, the declaration of the function member of the class requires as input the object itself (i.e., \textit{self}), the current value of the buffer (i.e., \textit{B\_now}), the value for the \textit{reservoir}, the \textit{cushion} and the maximum and minimum values of the rate (i.e., respectively \textit{R\_max} and \textit{R\_min}).

\begin{Verbatim}
    def f(self, B_now, reservoir, cushion, R_max, R_min):
        # The function f corresponds to the line equation between the 
        # points (r,R_min) and (r+cu,R_max) when the value of Buf_now 
        # is bounded by r and r+cu
        return B_now * ((R_max - R_min) / cushion) + 
        		(R_min - ((reservoir / cushion) * (R_max - R_min)))
\end{Verbatim}

WRITE THE EXPLANATION OF FUNCTIONS MAXR AND MIN R

\begin{Verbatim}
    def maxR(self, constraint):
        Rates = self.feedback['rates']
        results = []
        for i in Rates:
            if (i < constraint):
                results.append(i)
        return max(results)

    def minR(self, constraint):
        Rates = self.feedback['rates']
        results = []
        for i in Rates:
            if (i > constraint):
                results.append(i)
        return min(results)
\end{Verbatim}

The method member of the class defined below is the actual implementation of the BBA0 algorithm. In order to reproduce the behavior depicted in Figure ~\ref{ratemapBBA0}, the percentages for the
\begin{itemize}
\item \textit{reservoir} is setted at $15\%$;
\item \textit{cushion} is setted at $65\%$;
\item \textit{upper-reservoir} is setted at $20\%$;
\end{itemize}
In addition, the values of R\_max, R\_min, R\_curr and B\_now are taken from the \textit{Base Controller}.
\begin{Verbatim}
    def calcControlAction(self):

        # Retrive current iteration variables
        percentage_reservoir = 0.15
        percentage_cushion = 0.65
        percentage_upper_reservoir = 0.20
        reservoir = self.feedback['max_buffer_time'] * percentage_reservoir
        cushion = self.feedback['max_buffer_time'] * percentage_cushion
        R_max = self.feedback['max_rate']
        R_min = self.feedback['min_rate']
        R_curr = self.feedback['cur_rate']
        B_now = self.feedback['queued_time']
\end{Verbatim}

In this part begin the actual implementation of the BBA0 algorithm, in the same way as it is explained by the pseudo-code in the previous section.

Hence if the current value of the rate during the streaming of the content is equal to the maximum value of the rate, the upper-bound of the rate (i.e., R\_plus) is setted to the maximum value of the rate; otherwise it is setted to the minimum value computed with the function \textit{minR}.
The same logic is adopted to compute the lower-bound of the rate (i.e., R\_minus).
\begin{Verbatim}
        # Compute upperbound
        if R_curr == R_max:
            R_plus = R_max
        else:
            R_plus = self.minR(R_curr)

        # Compute lowerbound
        if R_curr == R_min:
            R_minus = R_min
        else:
            R_minus = self.maxR(R_curr)
\end{Verbatim}

In the following, the goal is to compute the next value of the rate, depending in which region the current value of the buffer lies and we can have four cases :
\begin{enumerate}
\item the current value of the buffer is in the ''lower''-reservoir area: in this case the next value for the rate will be equal to the lower-bound of the rate;

\item the current value of the buffer is in the ''upper''-reservoir area: in this case the next value for the rate will be equal to the upper-bound of the rate;

\item the current value of the buffer is in the cushion area: in this case the rate-map function is applied and:
\begin{itemize}
\item if $f(B) \geq R_{plus}$ then the next value of the rate is calculated as the maximum value of the rate computed with the \textit{maxR} function;
\item otherwise, if $f(B) \leq R_{minus}$ then the next value of the rate is calculated as the minimum value of the rate computed with the \textit{minR} function;
\end{itemize}

\item if none of the previous option is true, then the next value of the rate will be equal to the current one.
\end{enumerate}

\begin{Verbatim}
        # Compute new rate based in current buffer region

        # Buffer in reservoir area
        if B_now <= reservoir:
            Rate_next = R_min

        # Buffer in upper reservoir area
        elif B_now >= reservoir + cushion:
            Rate_next = R_max

        # Buffer in cushion area
        elif self.f(B_now, reservoir, cushion, R_max, R_min) >= R_plus:
            Rate_next = self.maxR(self.f(B_now, reservoir, cushion, R_max, R_min))
        elif self.f(B_now, reservoir, cushion, R_max, R_min) <= R_minus:
            Rate_next = self.minR(self.f(B_now, reservoir, cushion, R_max, R_min))
        
        else:
            Rate_next = R_curr

        return Rate_next

\end{Verbatim}

\subsection{Experiment setup}
As explained in ~\citep{RamonAparicio}, two VMs are used: one that act as server and one as client. The client machine uses the \texttt{192.168.1.1/24} address, while the server machine uses the \texttt{192.168.1.254/24} address.

So, the client play the content using the DASH protocol and a video is hosted on the server. In order to play the video we use the TAPAS player, that act as a DASH player, which generates the HTTP requests for the chunks of the video in different quality, depending on the adaptation algorithm adopted. In our case, the adaptation algorithm, or \textit{controller}, is the BBA0 controller. So, to client-side, from the directory \texttt{~/tapas-master} we execute the command:

\begin{Verbatim}
DEBUG=2 python play.py -m nodec -a BBA0 
	-u http://192.168.1.254/car-20120827-manifest.mpd
\end{Verbatim} 

and the log files of the playing are saved as log files in the client directory \texttt{$\sim$\slash tapas-master\slash log\slash BBA0\slash}.
From these log files we will plot them using the script \texttt{plot\_metrics.sh} located in the directory \texttt{$\sim$\slash Documents\slash scripts}.
Notice that, since the two VMs are not connected by a real network but via virtualization , the values of the bandwidth estimated by the client are simulated as  realistic network bandwidth values using the script called \texttt{bw\_evol.sh} in the folder \texttt{$\sim$\slash Documents\slash scripts}.

Observe that the script \textit{play.py} has been properly modified, in order to include the BBA0 controller.
In addition, the script \textit{plot\_metrics.sh} has been modified in order to automatically oper the most recent file in the folder \texttt{$\sim$\slash tapas-master\slash logs\slash BBA0}, if no file are specified when the script is executed. This is done by adding the following code in the script:

\begin{Verbatim}
if [ ! -z $1 ]
then
log_filename="../../tapas-master/logs/BBA0/$1"
else
log_filename="../../tapas-master/logs/BBA0/$(ls ../../
		tapas-master/logs/BBA0  -Art | tail -n 1)"
fi
echo "Opening: $log_filename"
\end{Verbatim}


\subsection{Results and Conclusion}

\begin{figure}[H]
  \begin{center}
    \includegraphics[width=0.7\textwidth]{res_ten_cushion_seventyfive}
  \end{center}
  \caption{Plot of log-file using a reservoir at $10\%$, an upper reservoir at $15\%$ and a cushion at $75\%$}\label{resten}
\end{figure}

\begin{figure}[H]
  \begin{center}
    \includegraphics[width=0.7\textwidth]{res_fifteen_cushion_sixtyfive}
  \end{center}
  \caption{Plot of log-file using a reservoir at $15\%$, an upper reservoir at $20\%$ and a cushion at $65\%$}\label{resfifteen}
\end{figure}



%------- BIBLIOGRAPHY -----------
\bibliography{bibliography}
\bibliographystyle{plain}

\end{document}

